i8086 - 16 битный проц
Он мог адресовал 1мб оперативки(с помощью 2 регистров). Адресс ссотоит из двух частей segment : offset. Про оффсет мы знаем(и сейчас впринцыпе мы адресуемся ими)

1) Режим real mode 
Segments(16 bit registres):
CS - code
DS - data
SS - stack
ES - extra
Сначала, потом добавились в 286 еще 2
FS - | не нагружены ничем
GS - |

Как вычислял адресс - seg * 16 + off
Каждый битик этого числа называется линий a0...a19. Также раньше можно был включить 
Есть косяк - там вылезает за 1МБ
>>> seg = 2 ** 16 - 1
>>> off = 2 ** 16 - 1
>>> seg * 16 + off - 2 ** 20
65519
>>> 2 ** 16
65536

Когда выходили - бралось по модулю

Чем плохо?
.) Пока работает одна программа - все хорошо. Когда много прог - каждая имеет доступ по памяти во всей памяти

2)Защищенный режим работы
Появилось 4 кольца с разными правами
0 кольцо - макс права
3 кольца - минимальные права.
Отсальные что-то среднее. И их обычно не используют

На что влияют права?
3 кольцо - ограничено к памяти, к внешним устройствам и некоторые команды не работают(например сменить кольцо)

Адресс интерпретируется как seg : off
Seg : |index|G/L|RPL|RPL - права, G/L + index - описывает дескриптор сегментов(собственно сам сегмент)(глобальный(gdtr) или локальный(никому не нужны) + индекс)
       15    2   1   0
Внутри структурке много полей
база - то, что нужно прибавить к смещению.чё
лимит - куда можем адресоваться


Есть селектор регистор и дескриптор. Селектор - что лижит. Регистор где лежит. Дескриптор в табличке что лежит
В реальности у регистра есть еще "скрытая часть", которая сохраняет смещение. и при разных режимах оно просто по разному пересчитывается

.)привелегии
внутри CS RPL - называется CPL - current prevelige level - права, которые у нас есть.
Можно понизить свои права записав в CPL 3 большее по модулю число. Нужно чтобы ОС вернула права пользовател при возврате из обработчика
Сейчас вместе с вызовом обработчика можно настроить переключение привелегии.

.) 32 битный мир
Флат модель - все сегменты имели базу 0 и лимит 4гб
.) 64 битный
флат из прошлого - тины

Как написать обращение полностью?
раньше mov al, [ebx]
mov al, ds:[ebx]

также можно
seg ds
mov al, ds:[ebx]

Как по умолчанию?
call jmp - cs
push pop - ss
[] - 
	если базовый регистр - bp ebp esp, то ss
	иначе ds
movs - es

3) 32-битный защищеный режим
Выбор режим зависит от размера загруженного дескриптора в CS
при переключении из 16 не меняется теневая часть.
4) v86 - подрежим защищенного
работает по 3 уровню кольца и адресация в реальном режиме



*** 26.05.2018 ***
5)х64
От сегментов DS ES SS не осталось ничего. Он считает что сегмент имеет базу ноль и сдвиг максимум.
От сегмента CS осталось поле прав. В дескрипторе CS указывается битность сегмента также. 
Между различными вариантами одного режима можно переходить спокойно.

При запуске 32 битных приложений подключаются 32 битные библиотеки SysWOW64.
При инициализации в юзерспейсе запускается NTDLL.dll.
	То есть если у вас 64 битный процесс запускается 64 битнй NTDLL и он грузит 64 винапи библиотеки.
        Если 32 - NTDLL запускает WOW и он уже подгружает 32 битные приложения. То есть у вас все 32 битные либы и еще NTDL.
                       
FS и GS: от них осталось поле базы.
Как было в 32 битах? 
	FS используется например для тред локал сторадж. Например мы вызываем винапи функцию и нам вернулся false, С помощью GetLastError можно получить последнюю ошибку. Но вот проблема: вызвали функции их разных тредов. Получается мусор. Поэтому сделали тред локал переменные, чтобы хранить переменные для конткретного треда. Такие образом по FS:18 мы попадаем в разные места оперативкию.(попадаем в THREAD ENVIRENMENT BLOCK при использовании FS)
	GS ни на что
В 64 битах FS стал указывать на 32 TEB, а GS на 64 TEB.



Страничная адрессация
У нас есть PDE и PTE
Смотрим картинки как они организованы
Так можно адресоваться 4кб
как адресоваться 64кб
