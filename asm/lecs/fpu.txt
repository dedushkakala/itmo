.)Исходно это было опциональная микросхемка. Назывались к каждой архитектуре - цифру 6 на цифру 7
Начиная с пентиумов это уже не отдельная микросхемка. Но названия х87 осталось

Отличительная черта - нельзя свапать данные между регистрами проца и сопроца.

.)У него 8 80 битных регистров. Это r0...r7. Yапрямую никто не делает. st0...st7 для обращению как к стеку. 
.)Он может в 16-64 и 80 битные флоты. 16-64 целые и BCD80(10 байт). Когда обращается на чтение или на запись - читается то количество байт, которое надо.

.)Какие конвенции? В начале вызова  стек должен быть пустой. Когда конец 
	- если не возвращается ничего, то стек очистить
	- если возвращать, то на вершине стека надо вернуть

Команды:
1)загрузка

FLD dword/qword/tbyte[adress_mem] пуш на стек дробных чисел
FILD --||-- пуш на стек целые числа
FBLD --||-- пуш BCD80

FST - поп, но не выкидывать значение
FSTP - еще прокрутить стек

FLDZ/FLDI - загрузить константу

можно завести 
C25: dd 2.5

2)обработка
fxch fx0, fx* - поменять какие-то значения

fadd/fiadd/faddp - сложить. Если 1 арг - st0 + * -> st0. Если 2, то *1 + *2 -> *1
fsub/fsubr - вычесть из первого второй/второго первый и пишет в первый
fmul
fdiv/fdivr

fprem - остаток от деления путем вычитания.

fabs, fchs, frndint, fsqrt - делает все для st0
fsin, fcos, fptan, fpatan

ffree st* - освободить
fincstp, fdecstp - покрутить стек

fnop - ничего не делать
fcom/ficom - сравнить и записать в флаги в свои флаги
fcomi - сравнить и записать в флаги проца.


Выводы:
1)конверсия
	- из целые в дробные - надо знать, что не надо конвертить беззнаковые числа во флоты. Беззнаковые есть команда FILD
	- дробные в целые - округление к нулю - FIST(но это не С правила округления). Если хотим по правилам, то надо переключить режим конверсии(по дефолту - к ближайшему четному) + FIST + переключить обратно.