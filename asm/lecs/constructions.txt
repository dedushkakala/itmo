Прога состоит из секций - регион памяти, который (если честно) описывается exe-шником. Размер секций - фиксированное. 
.text - секция для кода. Может только исполняться и читать
.rdata - секция для данных, которые могут быть только считанные
.data - данные доступные и для чтения и для записи. Данные запишутся в exe полностью.
.bss - секция для неинициализированных данных. Данные запишутся только сколько надо выделить и заполнит ее нулями(но это не точно).


Стек и хип.
Стек свой для каждого треда. Стандартно он около 2 мб. 

Как писать if
1) if (eax == 5 && ebx < 3)
	X
 
  cmp eax, 5
  jne le
  cmp ebx, 3
  jnb le

  X

  jmp lx

le: Y

lx: Z


2) if (eax == 5 || ebx < 3)
	X

  cmp eax, 5
  je lz
  cmp ebx, 3
  jnb le

lz: X

  jmp lx

le: Y

lx: Z


Циклы:
1) do...while
do 
  X
while(eax != 0);

L1:
  X
  text eax, eax
  jnz L1


2)while

while (eax != 0)
  X

L1: 
  cmp eax, 0
  jz L2
  X
  jmp L1

L2:  

3) while upgraded(2 команды на цикл)

if (усл)
  do 
    X
  while(усл);


  cmp eax, 0
  jz L2
L1: 
  X
  cmp eax, 0
  jnz L1

L2:  

Если компилятор может доказать, что while эквивалентный do...while, то он оптимизирует

4) for - тот же while + инициализация + деланье действия вконце цикла

NB: не надо разделять cmp/test и jnz, так как проц делает из этого одну команду.


switch

switch(eax) {
case 1: 
  X;
  break;
case 3:
case 4:
  Y;
case 6:
  Z;
}

  cmp eax, 6
  ja le
  jmp dword[eax * 4 + table]

L1: X
    JMP LE
L2: Y
L3: Z


section .rdata
table dd LE, L1, LE, L2, L2, LE, L3
LE:

------------------------------
Calling convention
------------------------------
1) Как возвращать значение
Можно или в регистре или на стеке. Например в регистре можно сохранять если нету оперативки.

2) Как передаем аргументы
Аргументы можно в регистры - но если много, то плохо.

Рассмотрим следующие стандарты --- 32-битные конвенции
название - где - порядок - кто выкидывает аргументы из стека
cdecl - stack - обратный(пихаем с конца) - caller
stdcall - stack - обратный(пихаем с конца) - called(f)
pascal - stack - прямой(пихаем с начала) - called(f)
fastcall - reg(first arguments) and stack(это скорее идея и как реализовано это неточно) - не договорились

3) Как возвращается значение
Все договорились на аккамуляторе(то есть eax 4 - байта или al - байт, ax - 2 байта, edx|eax - 8 байт) 

4) Что делать с большими типами
Кто должен выделять память под них и где это выделять

Есть одна проблема - как выделяется память - так ее надо и освобождать. Значит логично, что надо чтобы caller выделял память под память. И собсвтенно его передают 0 аргументом.

5) Какие регистры вызываемая функция может портить.
Какие нельзя портить - ebx, ebp, esi, edi
Остальные eax, ecx, edx - можно портить.

6) Что с методами?
По дефолту thiscall - конвенция для методов. это stdcall + ecx передать this
Если не thiscall - this уходит в 0 параметр. И там все плохо с порядок с возвращаемыми типами. У одного метода плохо - тип он плохо совместим с С.
7) Если хотите изменить напрямую в функции
int __cdecl f(int x);

8) Пример printf("%s", p):
-----
cdecl
-----
push p
push pstr
call printf
add esp, 8

======
stdcall
======
push p
push pstr
call printf


9) Пример как достучаться до аргументов
inf f(int a, int b) { return a * 2 + b; }

-----
cdecl
-----
Как НЕ ДОДЛЖНА выглядеть 
pop ecx
pop ebx

Как ДОЛЖНО выглядеть:
mov eax, [esp + 4]
add eax, eax
add eax, [esp + 8]
ret

Лайфхак: писать смещение относительно 
Если мы еще запущим ebx, ebp, esi
push ...
mov eax, [esp + 4 + 4]
...

======
stdcall
======
mov eax, [esp + 4]
add eax, eax
add eax, [esp + 8]
ret 8 <- сколько надо выкинуть после снятия sp


10)
cdecl может в неопределенное количество аргументов. Так как функция не знает количество аргументов.
Но вот stdcall - есть ret N и это как бы поменьше кода

11)Как называются функции
в С добавляется подчеркивание
В stdcall _exit@4
В С++ все грустно и все мешается

12)Agner. Colling convention