Режими работы процессора.
У проца несколько режимов. При переходе из одного режима в другой - коды команд немного меняются и поэтому код будет выполняться все по другому.

Длина комманды в х86 от 1 до 15 байт и сейчас свободных адресов нет

Почему все ломанулись в х86?
.)Не хватало 2^32 адрессов(!!!не оперативки!!! - прочитать AWE)
.)Фрагментация памяти - мы выделили 3 кусочка, освободили средний а потом это место никак не заюзать если хотим кусочек больше

Как изменилось?
1)Регистры : 
	8 регистров из прошлого расширились: EAX -> RAX
	RSI, RDI, RBP, RSP появились SIL - самые младшие 8 бит
	добавили еще 8 регистров - стало 16 регистров: R8 .. R15. R*D, R*W, R*B(вместо * цифра) - младшие DWORD, WORD, BYTE 
	Написать команду что-то новое с *h регистрами нельзя, но если очень хотим можно нужно к команде дописать префикс
	Добавили xmm8 .. xmm15
2)Система адрессации
Что можно указать в квадратных скобочках?

| RAX + RAX            |
| RCX +  .    1        |
|  .     .    2        |
|  .     .  * 4 + off32|
|  .     .    8        |
| R15 + R15            |

Во втором нельзя указать RSP
Вместо первых двух слагаемых можно написать RIP

Вопрос про константу. Раньше регистры и константа были 32 бита и -1 означало сдвинуться на FFFF. Сейчас константа со знаком
Теперь проблемы:
1)нельзя обращаться по метке так как она 64 битная. Поэтому сейчас обращаются через RIP + смещение.

Исключчения c 64 константами:
1)MOV AL/AX/EAX/RAX, [offset64]
2)MOV REG, const64
В остальеых все равно константа 32 битная

3)команды
.)любые команды которые модифицируют 32 битные регистры - модифицируют всю часть - сразу записывается в старшие  нули
MOV eax, ecx - грузит младшие, а страшие 32 бита обнуляется

Ex: хотим загрузить 16 битную константу
movzx eax, word[...]

.)выпилили 
	AAA, AAD, AAM, AAS, DAA, DAS - команды для 10 ричного счета (4бита под знак)
	BOUNDб INTO - проверка индекса на размер
	PUSHAD/POPAD - сохранить регистры
	LOS/LES
	SALC
	PUSH/POP CS, DS...
	JMP/CALL for absolute
	short from of INC/DEC -> REX
	ARPL
	SESENTER/SYSEXIT

4)конвенции вызова
	.)конвенция всего мира - unix64 - под не виндой
		ARG: (RDI, RSI, RDX, RCX, R8, R9) и XMM0..7 : void f(int a, float b, int *c) -> EDI, XMM0, RSI. Для вар аргов надо в RAX записать количество записанных в xmm. Что не влезло в обратном порядке
		RES: RAX или RDX::RAX или XMM0
		SAVE: RBX, RBP, R12..R15
		RED ZONE: если вам хватает 128 байт и ты никого не вызываешь - можешь не опускать стек поинтер
		
	.)конвенция майкрософта - fastcall64 - под виндой
		ARG: (RCX, RDX, R8, R9) или (XMM0..3) : void f(int a, float b, int *c) -> RCX, XMM1, R8. остальные лежат в обратной стороне.
		RES: EAX или XMM0
		SAVE: RBX, RBP, RSI, RDI, R12..R15, xmm6..xmm15
		SHADOW SPACE: сверху от адреса возврата 8 * 4 байта зарезервированного места. Туда можно сохранить 4 своих регистра.

