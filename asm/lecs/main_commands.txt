Софт
Отладчик OllyDbg2\msvc\qtcreator
компилятор yasm(nasm)
  -f win32 input_name <-o output_name>
  -f elf
  -f machO
потом надо слинковать
link.exe нужно найти 32 битности у визуалки
(link.exe /subsystem:windows(console) - консольное приложение или приложение windows
/libpath:<c:\lib - путь к библиотеке>
/defailtlib:kernel32.lib /defaultlib:user32.lib /entry:main)

gcc - linux(gcc flag_compule_to_32 input_name)
нотация Intel(мы ) и GNU(с процентиками и тд)


зубков ассемблер для dos windows и unix - книга
документация intel или amd

!!! Что происходит в общем !!!
Будет asm x86

x86 появилась в 1978 году
Так сложилось что оно получило широкое распростронение на ПК, но на телефонах ничего нет.
Была средняя 16-битная ISA.(были 20 бит адреса)

Первый процессоры нормальный
i8086
i80186
i80286
Понятно почему x86 - начало и в конце 86

Три лицензии сейчас intel, amd, и одна свободная которая гуляет по компаниям.
i80386 - крупное расширение набора команд и добавился мод на 32 битный процессор.
дальше
i80486
Pentium(инордер суперскаляр) и Pentium Pro(оут-оф-ордер суперскаляр) - стоит как чугунный мост
Pentium MMX(добавили модные команды MMX)  - поменьше чем чугунный мост
Pentium II
Pentium III
Pentium D\Pentium IV - неудачно, Athlon 64 победил
Поэтому из Pentium III -> Pentium M -> Core 2 и оно взлетело(научился 64 битный режим работы)


У amd
K6
K6-2
K6-3
Athlon
Athlon 64(!!64 битный режим работы!!) - архитектура AMD64/x86-64/x64 - расширение x86
Itanium - итаник, неудачно(архитектура IA64)

х86 - reg-mem 2
Какие есть регистры общего назначения

!!! i8086 - i80286
16 бит: AX(Аккамулятор) CX(count) DX(data) BX(base) SI(source index) DI(desination index) SP(стек поинтер) BP(бейс поинтер)
регистры неважны, кроме меток

*X = {8бит(*H), 8бит(*L)} *={A, B, C, D};

!!! i80386
32 бит: ко всем еще добавили E: EAX EBX EDI + все старые
В 32 мире к 16 битным ниоч, а к 8 битным достаточно бодро, ну 32 битные быстрее всех

!!!Есть другие регистры
EIP - Instruction pointer
EFLAGS - регистры флагов(битовые исходы которые устанавливаются в зависимости от чего-то)
  ZF - если в результате арифм действий команды ноль - флаг нуля,
  CF - флаг переноса (переполнение, заем)
  SF - флаг знака - дополнение до двух
  DF - флаг направления - влияют на строковые команды
  это битики EFLAGS

!!!Команды
1)MOV eax, EBX (eax = ebx)
    al, bh
    ax, [eax]
    [ecx + ebx*4], ah

Что может быть в квадратных скобочках?
через 32 [{eax, ebx, ..., edi} + {eax, ebx.... edi] * {1, 2, 4, 8} + off32]
через 16 [{bx, bp} + {si, di} + off16]

.) mov dword[ecx], 5
      word
      byte
без спец слова он не понимает какого размера цифра или память

Пример Hello world
/* Код на асме */
  extern _printf
  section .text
  global _main

_main:
  push string
  push format
  call _printf
  add  esp, 8
  ret

  section .rdata

fromat: db "%s", 0xA, 0
string: db "Hello, World!", 0


Метки пишутся без табуляций
код пишется с одной табуляцией

2)xchg - поменять значения - очень долго работает по памяти(она атомарна). То есть если вы хотите поменять регистр и память, то лучше написать мувы.
3)bswap - имеет смысл только по 32 регистрами. Жрет регистр и меняет порядок байтиков(конвертер между endiands)
4)movsx/movzx - как мов, только загрузка из меньшего в большее(отличие в том, что zx добивает старшие битики нулями, а sx - чилом знака).
!!! повторить дополнение до двух!!!
5)lea reg_id mem_id - взять адрес mem_id и записать в reg_id. (Халявное умножение на 4 или сложение двух регистер).
!!! Agner blog - про скорость выполнения команд.
Aida 64 - можно померить скорость команд
отрубить турбо буст(внизу слева иконка и правой кнопкой)

6) push/pop  - запоминает значение регистра в стек
esp указывает на первые данные
При запоминании esp уменьшается на размер того, что положили
Не следует делать пуши и попы от размера меньше чем битность системы(сильно бьет по памяти)

7)pusha/pushad/pushaw/popa/popad
запихать на стек все 8 регистров
pushaw - все 16 битные регистры
pushad - все 32 битные
pusha - один из двух

попы - читает 7, а asp пропускать
и дополнительные буквы означают тоже самое

!!!КОМАНДЫ УПРАВЛЕНИЯ!!!
1)jmp - регистр, метка, обращение по памяти. По дефолту - ваша битность. Эквивалентно MOV EIP DATA/
2)call/ret/ret const
Тупо делает на стек пуш адрес след команды
и прыгает по указанным данным

ret - возвращает
ret const - ret + добавляет на стек константу
3)Jcc - условный переход
JC - carry
JZ - zero
JS - sign
JA(E) - above   беззнаковые
JB(E) - below   беззнаковые
jG(E) - greater знаковые
JL(E) - lower   знаковые
Также после J можно добавить N - означает отрицание.
4)CMOVcc reg32, reg32 - условный мув

!!!КОМАНДЫ АРИФМЕТИКИ!!!
Они ставят флаги
1)ADD - +=
2)ADC - += плюс carry flag
ADD eax, ecx
ADC edx, ebx
сложение 64 чисел на 32 битных подчислах
3)SUB/SBB - -= плюс вычитает керри
4)MUL/IMUL arg - беззнаковое\знаковое умножение. Либо регистр либо память
Работа зависит от битности аргумента
если 32 - edx:ead = eax * arg32, то есть ead - младшие 32 и edx - старшие
16 - везде убрать e
8 - ax = al * arg8

Можно
IMUL dst, src <=> dst *= src
IMUL dst, src, const <=> dst = src * const

4)DIV arg/IDIV
обратно стандартному умножению
eax=edx:eax/arg32 - округляется к нулю
edx=edx:eax%arg32

Если частное не умещается в eax, то возникает экспешн как деление на ноль
Поэтому надо или обнулить edx(если DIV), иначе cwd/cdq(для IDIV) - заполнениями знаками

5)INC/DEC - инкремент дикремент
не влияют на флаг переноса
6)NEG - инверсия знака(инвертировать + добавить один)
7)AND/OR/XOR/NOT
xor eax, eax - обнуление регистр
8)CMP/TEST = SUB/AND но не записывает результат, а только записывает флаги.
test eax, eax - проверка на нормаль
cmp ead, ebx - сравнить.

9)SHR/SHL reg, const/CL - логический сдвиг
При сдвиге влево справа битики заполняются ноликами - это эквивалентно умножению на степень двойки. Бит коорый затирается записывается во флаг переноса.
При сдвиге вправо битики слева нолики, а справа последний в флаг переноса - деление для беззнаковых
10)SAR/SAL -арифметический сдвиг
Лево - тоже самое
Вправо - старшие битики записываются значением которое было раньше старшим.
11)SHLD, SHRD reg, reg, const/cl
новые значение берутся из второго регистра(то есть что-то тип двигает shld eax, ebx, 3, то будет сдвиг eax|ebx, если направо то ebx|eax. 
12)RCR/RCW - тоже самое что и сдвиг, только циклический вместе с cf. Вращается -eax -> cf --
							 	               |--------<--|
13)ROR/ROL - цикл сдвиг без cf. Который передвинулся записывается в cf.
14)UD2 - программа которая вывалит твою прогу.
!!! Пример !!!
1) 
число -6
11111010
делаем SAR 1
11111101 -3
еще раз -> -2 -> -1 -> -1
То есть это деление на 2 с округлением вниз

2) модуль c ифОм
test eax, eax
jns L1
neg eax


L1:...
3)модуль без ифа
mov edx, eax | вместо двух команд можно написть cdq
sar edx, 31  |
xor eax, edx
sub eax, edx
для положительных в edx - 0 и eax не изменяется
для отрицательных в увч - -1 и делаем инвертирование и вычитаем -1

4)деление

mov edx, eax
sar edx, 31
xor ead, edx
sub ead, edx

shr eax, 3
xor eax, edx
sub eax, edx

- это тупо
mov edx, eax
sar edx. 31
shr edx, 32 - 3
add eax, edx
sar eax, 3

000001100
111110110


