\documentclass[12pt, a4paper]{scrartcl}
\usepackage [utf8] {inputenc} 
\usepackage [english,russian] {babel}
\usepackage{indentfirst}
\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage [warn] { mathtext }

\begin{document}
\LARGE{\textbf{Федер Евгений, Домашнее задание №1}}\par

%%%%%%%%%%%%%%%%%%%%%%%%%%
\emph{\textbf{Задание 1.}}\par
\begin{enumerate}
	\item Построим конденсацию исходного графа, параллельно считая функцию для каждой компоненты отдельно. Это делается за $O(V+E)$
	\item Отлично, теперь мы получили ацикличный граф. Сделаем topsort для конденсации(собственно когда делали конденсацию на халяву ее получили).
	\item Будем считать функцию с права на лево в получившейся сортировке. Мы знаем, что нету ребер из элемента влево. На каждом шаге будем брать максимум из значений функции вершин, в которые есть ребра(там уже все посчитано). Считается за $O(V+E)$
\end{enumerate}
Время - $O(V+E)$\par
Как посчитать ответ? У каждой вершины есть закрепленная компанента связанности. Берем ее и для них уже посчитана функция.\par
Почему корректно? В компаненте своей он достигает все вершины, а также по конденсации может достигнуть компоненты, где все вершины тоже достижимы. Мы берем максимум из всех компонент которые мы можем достичь. Собственно это то, что мы хотели.
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage\emph{\textbf{Задание 2.}}\par
\begin{enumerate}
	\item Построим topsort конденсации исходного графа($O(V+E)$) и добавим их в список, чтобы первым был самый левый элемент. Также для каждой компаненты возьмем одну рандомную вершину.
	\item
	\begin{verbatim}
	for (i = 0; i < size(cond_graph); i++) {
	  if (cond_graph[i] is not used) {
	    add to result vertex of this companent
	    set cond_graph[i] used
	    dfs(i) in cond_graph // make used 
	   	                     // achievable 
	                         // cond_vertices
	  }
	}
	\end{verbatim}
	\item Таким образом мы получаем множество вершин $result$, что и является нашим ответом	
\end{enumerate}
Время - обе части работают за $O(V+E)$\par
Почему корректно? Компоненты из которых мы выбираем вершины находятся в компонентах, которые являются истоками(то есть в них не входят ребра), другие вершины мы не выбираем(если бы выбрали, то у вершины есть ребро в topsort которое идет слева, то есть мы бы прошли ее раньше). А истоки полюбому должны быть в этом множестве. ЧТД

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage\emph{\textbf{Задание 3.}}\par
Алгоритм не верен, вот граф на котором это не выполняется, потому что в результате это будет одна компонента сильной связанности, а нам нужно, чтобы их было две.\par
\includegraphics[scale=0.5]{asdasd.png}\par
В первый раз от начальной вершины мы пошли в 2 и 1, а потом в другую компаненту. Из-за этого получается что на этапе построения компонент мы пойдем в 2 компоненты.\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%
